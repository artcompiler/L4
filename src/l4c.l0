/* -*- Mode: javascript; indent-tabs-mode: nil; tab-width: 4 -*- */
/* vi: set ts=4 sw=4 expandtab: (add to ~/.vimrc: set modeline modelines=5) */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine.].
 *
 * The Initial Developer of the Original Code is
 * Adobe System Incorporated.
 * Portions created by the Initial Developer are Copyright (C) 2004-2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Adobe AS3 Team
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


public function eval(...args)
    ESC::evaluateInScopeArray(args, [], "");


// load asm
{
    use namespace "avmplus";
    use namespace "flash.utils";

    var fname = System.argv[0];
    if (fname==undefined) throw "no file name given";
    var fname = System.argv[0];
    var str = "var src = " + File.read (fname);
}

// parse json to object

{
    use namespace "avmplus";
    use namespace Parse;
    use namespace Gen;
    //print ("parsing");
    var top = [];
    var parser = new Parser(str,top);
    var nd = parser.program();
    var bytes = cg(nd).getBytes();
    Util::loadBytes(bytes);
}

// decode it

function getOffsetOfDefInBody(body, name) {
    for (var i=0; i<body.blocks[0].defs.length; i++) {
        //print("getOffsetOfDefInBody() name="+name+"="+ body.blocks[0].defs[i].name);
        if (body.blocks[0].defs[i].name == name) {
            return i;
        }
    }
    return 0;
}


function stripPunc(str) {
    return str.replace(/[_]/g, "-").replace(/ /g, "").replace(/[#.()]/g, "");
}

function genName({m, c, n, s, e, b, r, d, u}) {
    let name = ""
    // module
    if (m) {
        name += "M" + m
    }
    // closure
    if (c) {
        name += "C" + c
    }
    // table
    if (n) {
        name += "N" + n
    }
    // slot
    if (s) {
        name += "S" + s
    }
    // expression
    if (e) {
        name += "E" + e
    }
    // block
    if (b) {
        name += "B" + b
    }
    // reference
    if (r) {
        name += "R" + r
    }
    // def
    if (d) {
        name += "D" + d
    }
    // use
    if (u) {
        name += "U" + u
    }

    return name
}

var moduleNum = 0
function genModuleName() {
    moduleNum++
    return genName({m: moduleNum})
}

var closureNum = 0
function genClosureName() {
    closureNum++
    return genName({c: closureNum})
}

var nodeNum = 0
function genNodeName() {
    nodeNum++
    return genName({n: nodeNum})
}

var slotNum = 0
function genSlotName() {
    slotNum++
    return genName({s: slotNum})
}

var exprNum = 0
function genExprName() {
    exprNum++
    return genName({e: exprNum})
}

var blockNum = 0
function genBlockName() {
    blockNum++
    return genName({b: blockNum})
}

var refNum = 0
function genRefName() {
    refNum++
    return genName({r: refNum})
}

var defNum = 0
function genDefName() {
    defNum++
    return genName({d: defNum})
}

var useNum = 0
function genUseName() {
    useNum++
    return genName({u: useNum})
}

var nameStack = [ ]
function pushName(str) {
    if (!(str is String)) {
        throw str
    }
    print("pushName() " + nameStack.join("") + " " + str)
    nameStack.push(str)
    return str //nameStack.join("")
}

function popName() {
    let str = String(nameStack)
    nameStack.pop()
    return str
}


{
    genModuleName()

    var karyotypeStr = "";
    var configStr = "";
    var labelStr = "";
    var kname = fname.substring(fname.lastIndexOf("/")+1);
    var sharedLabelStr = ""
    var closureMap = { }
    var tableMap = { }

    var linkStr = ""
    var nodesStr = ""

    for each (var closure in src.bods) {
        closure.id = genClosureName()
        closureMap[closure.name] = closure
        //print("bods closure.id="+closure.id+" closure.name="+closure.name)
    }

    for each (let node in src.pool) {
        node.name = genNodeName()
    }

/*
    for each (var obj in src.objs) {
        obj.id = genTableName()
        tableMap[obj.name] = obj
    }

    for each (var table in tableMap) {
        configStr = "";
        detailedConfigStr = "";
        linkStr = "";

        var tableSize = table.slots.length;

        nodesStr += emitNodes({id: table.id, tokens: table.tokens});

        var offset = 1;
        var labelStr = sharedLabelStr;
        var others = []

        for each (var slot in table.slots) {

            slot.id = genSlotName()

            print("table.id="+table.id+" slot.id="+slot.id)

            var env = {
                id: slot.id,
                offset: offset,    // for link
                size: 100000,
                name: table.name,
                label: slot.name,
                tokens: slot.tokens,
                closures: closureMap,
                tables: tableMap,
                slot: slot
            }

            karyotypeStr += emitChr(env)
            nodesStr += emitNodes({id: slot.id, tokens: slot.tokens});
            labelStr = emitLabel(env, labelStr);
            linkStr = emitLink(linkStr, env);
            offset++;

        }

        let size = (tableSize?tableSize:tableSize+1)*100000
        var env = {
            kname: kname,
            id: table.id,
            name: table.name,
            label: table.alias,
            offset: 0,
            offset: size/2,    // for label
            scale: 2,
            size: size,
            tables: tableMap,
            closures: closureMap
        }


        labelStr = emitLabel(env, labelStr);
        karyotypeStr += emitChr(env)
        configStr += emitConfig(env)
        detailedConfigStr += emitDetailedConfig(env)

        var rootName = fname+"."+table.id
        Util::writeStringToFile(linkStr,rootName+".links");
        Util::writeStringToFile(labelStr,rootName+".labels");
        Util::writeStringToFile(configStr,rootName+".conf");
        Util::writeStringToFile(detailedConfigStr,rootName+"-detail.conf");

    }
*/

    let nodeIdeoSize    = 10000
    let closureIdeoSize = 100000
    let linkWidth = 10000

    for (let nid in src.pool) {
        let node = src.pool[nid]
        configStr = "";
        detailedConfigStr = "";
        linkStr = "";

        var nodeSize = node.length

        nodesStr += emitNodes({id: node.name, tokens: node.tokens});

        var offset = 1;
        var labelStr = sharedLabelStr;
        var others = []

        let count = 0
        for (let i=0; i < node.length; i++) {  // skip the last slot
            let slot = node[i]
            let slotId = node.name + "-" + count++
            let slotName = slot is String ? slot 
                : slot is Number ? "N"+(slot+1)
                : slotId
            let env = {
                id: slotId,
                name: slotName,
                offset: nodeIdeoSize/2,    // for label
                size: nodeIdeoSize,
                label: slotName
            }

            karyotypeStr += emitChr(env)
            //nodesStr += emitNodes({id: slotId, tokens: slot.tokens});
            //linkStr = emitLink(env, linkStr);
            labelStr = emitLabel(env, labelStr);
            
            offset++;

        }

        let size = (nodeSize?nodeSize:nodeSize+1)*nodeIdeoSize
        var env = {
            kname: kname,
            id: node.name,
            name: node.name,
            label: node[0],
            offset: 0,
            offset: size/2,    // for label
            scale: 2,
            size: size,
            nodes: src.pool,
            tables: tableMap,
            closures: closureMap
        }


        labelStr = emitLabel(env, labelStr);
        linkStr = emitNodeLink({id: nid, pool: src.pool, linkWidth: linkWidth}, linkStr);
        karyotypeStr += emitChr(env)
        configStr += emitConfig(env)
        detailedConfigStr += emitDetailedConfig(env)

        var rootName = fname+"."+node.name
        Util::writeStringToFile(linkStr,rootName+".links");
        Util::writeStringToFile(labelStr,rootName+".labels");
        Util::writeStringToFile(configStr,rootName+".conf");
        Util::writeStringToFile(detailedConfigStr,rootName+"-detail.conf");

    }

    for each (var closure in closureMap) {
        print("closure="+typeof closure)
        configStr = "";
        detailedConfigStr = "";
        linkStr = "";

        var closureSize = closure.slots.length + closure.blocks[0].exprs.length;

        nodesStr += emitNodes({id: closure.id, tokens: closure.tokens});

        var offset = 1;
        var labelStr = sharedLabelStr;
        var others = []

        /*
        for each (var slot in closure.slots) {

            slot.id = genSlotName()

            print("closure.id="+closure.id+" slot.id="+slot.id)

            var env = {
                id: slot.id,
                name: slot.name,
                offset: closureIdeoSize/2,    // for label
                size: closureIdeoSize,
                label: slot.name
            }

            karyotypeStr += emitChr(env)
            nodesStr += emitNodes({id: slot.id, tokens: slot.tokens});
            labelStr = emitLabel(env, labelStr);
            
            offset++;

        }
        */

        /*
        for each (var ref in closure.blocks[0].refs) {

            ref.id = genRefName()

            print("closure.id="+closure.id+" ref.id="+ref.id)

            var env = {
                id: ref.id,
                name: ref.name,
                offset: 50000,    // for label
                size: 100000,
                label: ref.name
            }

            karyotypeStr += emitChr(env)
            nodesStr += emitNodes({id: ref.id, tokens: ref.tokens});
            labelStr = emitLabel(env, labelStr);
            
            offset++;

        }
        */

        for each (var expr in closure.blocks[0].exprs.reverse()) {

            expr.name = genExprName()

            var env = {
                id: expr.name,
                name: expr.name,
                offset: closureIdeoSize/2,    // for label
                size: closureIdeoSize,
                label: expr.name
            }

            karyotypeStr += emitChr(env)
            nodesStr += emitNodes({id: expr.name, tokens: expr.tokens});
            labelStr = emitLabel(env, labelStr);
            
            offset++;

        }

        let size = (closureSize?closureSize:closureSize+1)*closureIdeoSize
        var env = {
            kname: kname,
            id: closure.id,
            name: closure.name,
            label: closure.alias,
            offset: 0,
            offset: size/2,    // for label
            scale: 2,
            size: size,
            tables: tableMap,
            closures: closureMap,
            nodes: src.pool
        }


        linkStr = emitExprLinks({id: closure.id, exprs: closure.blocks[0].exprs, pool: src.pool, linkWidth: linkWidth}, linkStr);
        labelStr = emitLabel(env, labelStr);
        karyotypeStr += emitChr(env)
        configStr += emitConfig(env)
        detailedConfigStr += emitDetailedConfig(env)

        print("closure="+typeof closure)
        print("closure.id="+closure.id);

        var rootName = fname+"."+closure.id
        Util::writeStringToFile(linkStr,rootName+".links");
        Util::writeStringToFile(labelStr,rootName+".labels");
        Util::writeStringToFile(configStr,rootName+".conf");
        Util::writeStringToFile(detailedConfigStr,rootName+"-detail.conf");
    }

    Util::writeStringToFile(karyotypeStr,fname+".karyotype");
    Util::writeStringToFile(nodesStr,fname+".nodes");
}

function emitNodes({id, tokens}, str) {
    if (!str) {
        str = "";
    }

    if (id) {
        str += "\n" + id + " "
    }
 
    if (tokens) {
        for each (let t in tokens) {
            str += t + ","
        }
    }
    return str
}



function emitNodeLink({pool, id, linkWidth}, linkStr) {

    print("emitNodeLink() id="+id);
    let from = pool[id]
    let outerWidth = from.length*nodeIdeoSize
    let outerSize = linkWidth
    let outerOffset = outerWidth / 2 - linkWidth / 2
    let outerId = "N" + (id+1)

    if (!from) {
        return linkStr
    }

    let to
    for (let i=0; i< from.length; i++) {
        if (from[i] is Number) {
            to = pool[from[i]]

            if (!to) {
                continue
            }

            let fromId = "N" + (id+1)
            let fromOffset = nodeIdeoSize / 2 - linkWidth / 2
            let fromSize = linkWidth
            let toId = "N" + (from[i]+1)
            let toWidth = (to.length===0?1:to.length)*nodeIdeoSize
            let toOffset = toWidth / 2 - linkWidth / 2
            let toSize = linkWidth

            linkStr += fromId + "_" + i + " " + outerId + " " + outerOffset + " " + (outerOffset+outerSize) + "\n" +
                       fromId + "_" + i + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

            linkStr += fromId + "_" + i + "_" + from[i] + " " + fromId + "-" + i + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
                       fromId + "_" + i + "_" + from[i] + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

            linkStr = emitNodeLink({pool: pool, id: from[i], linkWidth: linkWidth}, linkStr)
        }
    }

    return linkStr
}

function emitExprLinks({id:outerId, exprs, pool, linkWidth}, linkStr) {

    let outerOffset = exprs.length * closureIdeoSize / 2 - linkWidth / 2 
    let outerSize = linkWidth
    let to
    for (let i=0; i< exprs.length; i++) {
        to = pool[exprs[i].id]

        if (!to) {
            continue
        }

        let fromId = exprs[i].name
        let fromWidth = closureIdeoSize
        let fromOffset = fromWidth / 2 - linkWidth / 2
        let fromSize = linkWidth
        let toId = "N" + (exprs[i].id+1)
        let toWidth = (to.length===0?1:to.length)*nodeIdeoSize
        let toOffset = toWidth / 2 - linkWidth / 2
        let toSize = linkWidth

        linkStr += outerId + "_" + fromId + " " + outerId + " " + outerOffset + " " + (outerOffset+outerSize) + "\n" +
                   outerId + "_" + fromId + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

        linkStr += outerId + "_" + fromId + "_" + i + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
                   outerId + "_" + fromId + "_" + i + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

    }

    return linkStr
}

function emitLink({name, label, offset, toName, toOffset, toSize, closures, tables, slot}, linkStr) {

    let from
    if (closures[name]) {
        from = closures[name]
    }
    else if (tables[name]) {
        from = tables[name]
    }


    if (!from) {
        return linkStr
    }
    let to
    if (closures[slot.val]) {
        to = closures[slot.val]
    }
    else if (tables[slot.val]) {
        to = tables[slot.val]
    }
    if (!to) {
        return linkStr
    }

    let fromId = slot.id
    let fromOffset = 0 //offset
    let fromSize = closureIdeoSize
    let toId = to.id
    let toOffset = 0
    let toSize = (to.slots.length===0?1:to.slots.length)*closureIdeoSize

    return linkStr + fromId + "_" + offset + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
           fromId + "_" + offset + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";
}

function emitChr({id, label, size}) {
    return "chr - " + id + " " + id + " 0 " + size + " gpos25\n";
}

function emitLabel({id, size, label}, out) {
    let offset = size/2
    var label = label.replace(/ /g, "__");
    var str = id + " " + offset + " " + offset + " " + label + "\n";
    if (out.indexOf(str) < 0) {
        out += str
    }
    return out
}

// Emit a Circos conf file for each body
function emitConfig({kname, name, id, scale, closures, tables, nodes}) {
    var chrs = ""
    var radius = ""
    var color = ""

    for (let closureName in closures) {
        if (chrs.length > 0) {
            chrs += ";"
        }
        chrs += closures[closureName].id
    }

/*
    for (let tableName in tables) {
        if (chrs.length > 0) {
            chrs += ";"
        }
        chrs += tables[tableName].id
    }
*/

    for each (let node in nodes) {
        if (chrs.length > 0) {
            chrs += ";"
        }
        print("emitConfig() node.name="+node.name)
        chrs += node.name
    }


    return "karyotype = ../" + kname + ".karyotype"
        + "\nchromosomes_units = " + closureIdeoSize
//        + "\nchromosomes_display_default = yes"
//        + "\nchromosomes_scale = "+ name + ":" + scale
        + "\nchromosomes = " + chrs
        + "\nchromosomes_color = /C/=closurecolor;/N/=tablecolor;"+id+"=highlightcolor"
        + "\n<<include ../" + kname + ".ideogram.conf>>"
        + "\n<<include ../" + kname + ".ticks.conf>>"
        + "\n<plots>"
        + "\n<plot>"
        + "\ntype = text"
        + "\ncolor = black"
        + "\nfile = ../" + kname + "." + id + ".labels"
        + "\nr0 = 1r+10p"
        + "\nr1 = 1r+200p"
        + "\nshow_links     = no"
//        + "\nlink_dims      = 4p,4p,8p,4p,4p"
//        + "\nlink_thickness = 1p"
//        + "\nlink_color     = grey"
        + "\nlabel_size   = 0p"
        + "\nlabel_font   = condensed"
        + "\npadding  = 0p"
        + "\nrpadding = 0p"
        + "\n<rules>"
        + "\n <rule>"
        + "\n importance = 100"
        + "\n condition = eval( _CHR_ eq \"" + id + "\")"
        + "\n label_size = 10p"
        + "\n label_color = grey"
        + "\n link_color = white"
        + "\n </rule>"
        + "\n</rules>"
        + "\n</plot>"
        + "\n</plots>"
        + "\n<image>"
        + "\nfile  = ../" + kname + "." + id + ".svg"
        + "\n<<include ../image.conf>>"
        + "\n</image>"
        + "\n<<include ../housekeeping.conf>>"
        + "\n<links>"
        + "\nz = 0"
        + "\nradius = 0.95r"
        + "\nbezier_radius = 0r"
        + "\nbezier_radius_purity = 1"
        + "\n<link "+id+">"
        + "\nshow = yes"
        + "\ncolor = ribboncolor"
        + "\nstroke_thickness = 1"
        + "\nstroke_color = ribboncolor"
        + "\nfile  = ../" + kname + "." + id + ".links"
        + "\nribbon = yes"
        + "\nflat = yes"
        + "\n</link>"
        + "\n</links>"
}

// Emit a Circos conf file for each body detail
function emitDetailedConfig({kname, id, name, scale, offset, size, closures, tables, nodes}) {

    // show details of the current chr and hide details of the other chrs

    var chrs = ""

    var detailedRadius = ""
    var detailedColor = ""
    var detailedZoom = ""
    var detailedLabel = ""

    for (closureName in closures) {

        let closure = closures[closureName]

        if (closureName != name) {
            // if not the focus chr, then just add name to chrs
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closure.id
        }
        else if (closure.slots.length === 0 &&
                 closure.blocks[0].refs.length === 0) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closures[closureName].id

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = closures[closureName].id
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = " + offset + "u"
            detailedZoom += "\n end   = " + (offset+size-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }

        /*
        if (closureName === name && closure.slots.length > 0) {
            for each (var slot in closure.slots.reverse()) {  
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                    detailedColor += ";"
                }
                var detailedChr = slot.id  //chrName + "-" + stripPunc(slot.name)
                
                print("closure.id="+closures[closureName].id+" slot.id="+slot.id)
                
                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = " + offset + "u"
                detailedZoom += "\n end   = " + (offset+size-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"

                detailedChr = detailedChr.replace("$", "\\\\$")

                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }
        }
        */
        /*
        if (closureName === name && closure.blocks[0].refs.length > 0) {
            for each (var ref in closure.blocks[0].refs) {  
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                    detailedColor += ";"
                }
                var detailedChr = ref.id
                
                print("closure.id="+closures[closureName].id+" ref.id="+ref.id)
                
                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = " + offset + "u"
                detailedZoom += "\n end   = " + (offset+size-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedChr = detailedChr.replace("$", "\\\\$")
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                detailedLabel += "\n label_size = 14p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }
        }
        */

        if (closureName === name && closure.blocks[0].exprs.length > 0) {
            for each (var expr in closure.blocks[0].exprs) {  
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                    detailedColor += ";"
                }
                var detailedChr = expr.name
                
                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = " + offset + "u"
                detailedZoom += "\n end   = " + (offset+size-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedChr = detailedChr.replace("$", "\\\\$")
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }
        }

    }

    for each (let node in nodes) {
        let nodeName = node.name

        if (nodeName != name) {
            // if not the focus chr, then just add name to chrs
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName
        }
        else if (node.length === 1) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = nodeName
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = " + offset + "u"
            detailedZoom += "\n end   = " + (offset+size-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }
        else {
            // otherwise, include detailed chrs
            for (let i = 0; i < node.length; i++) {
                
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                    detailedColor += ";"
                }
                var detailedChr = nodeName+"-"+i
                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"

                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = " + offset + "u"
                detailedZoom += "\n end   = " + (offset+size-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"

                detailedChr = detailedChr.replace("$", "\\\\$")

                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }

        }

    }

    for (tableName in tables) {
        let table = tables[tableName]
        let tableId = table.id
        if (tableName != name) {
            // if not the focus chr, then just add name to chrs
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += tableId
        }
        else if (tables[tableName].slots.length === 0) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += tableId

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = tableId
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = " + offset + "u"
            detailedZoom += "\n end   = " + (offset+size-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }
        else {
            // otherwise, include detailed chrs
            for each (var slot in tables[tableName].slots /*.reverse()*/) {  
                print("table.id="+table.id+" slot.id="+slot.id);
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                    detailedColor += ";"
                }
                var detailedChr = slot.id  //chrName + "-" + stripPunc(slot.name)
                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"

                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = " + offset + "u"
                detailedZoom += "\n end   = " + (offset+size-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"

                detailedChr = detailedChr.replace("$", "\\\\$")

                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }

        }
    }

    return "karyotype = ../" + kname + ".karyotype"
        + "\nchromosomes_units = " + closureIdeoSize
        + "\nchromosomes = " + chrs
//        + "\nchromosomes_display_default = yes"
//        + "\nchromosomes_scale = "+ id + ":" + scale
        + "\nchromosomes_color = /C/=closurecolor;/N/=tablecolor;"+detailedColor
        + "\nchromosomes_radius = "+ detailedRadius
        + "\n<<include ../" + kname + ".ideogram.conf>>"
        + "\n<<include ../" + kname + ".ticks.conf>>"
        + "\n<plots>"
        + "\n<plot>"
        + "\ntype = text"
        + "\ncolor = black"
        + "\nfile = ../" + kname + "." + id + ".labels"
        + "\nr0 = 1r+10p"
        + "\nr1 = 1r+200p"
        + "\nshow_links     = no"
//        + "\nlink_dims      = 4p,4p,8p,4p,4p"
//        + "\nlink_thickness = 1p"
//        + "\nlink_color     = grey"
        + "\nlabel_size   = 0p"
        + "\nlabel_font   = condensed"
        + "\npadding  = 0p"
        + "\nrpadding = 0p"
        + "\n<rules>"
        + detailedLabel
        + "\n</rules>"
        + "\n</plot>"
        + "\n</plots>"
        + "\n<image>"
        + "\nfile  = ../" + kname + "." + id + "-detail.svg"
        + "\n<<include ../image.conf>>"
        + "\n</image>"
        + "\n<<include ../housekeeping.conf>>"
        + "\n<links>"
        + "\nz = 0"
        + "\nradius = 0.95r"
        + "\nbezier_radius = 0r"
        + "\nbezier_radius_purity = 1"
        + "\n<link "+id+">"
        + "\nshow = yes"
        + "\ncolor = ribboncolor"
        + "\nstroke_thickness = 1"
        + "\nstroke_color = ribboncolor"
        + "\nfile  = ../" + kname + "." + id + ".links"
        + "\nribbon = yes"
        + "\nflat = yes"
        + "\n</link>"
        + "\n</links>"
        + "\n<zooms>"
        + detailedZoom
        + "\n</zooms>"
}

public function compileHook (s:String)
{
    var t0 = new Date;
    var maker = new SwfMaker ();
    var bytes = ESC::compileStringToBytes (s);
    var bytes = maker.makeSwf ([bytes], null);
    print (bytes.length + " bytes in " + (new Date() - t0) + " ms");
    return bytes;
}



// chr - CHRNAME CHRLABEL START END COLOR
//      "       method#  0 size "

function karyoFromAbc(fname, abc) {
    var chr_count = 1;
    var ticket = 1;
    var out_str = "";
    var code_size = 0;
    var kname = fname.substring(fname.lastIndexOf("/")+1, fname.lastIndexOf("."));
    var start;
    var end = 0;

    for each (body in abc.bodies) {
        var band_str = "";
        /*
        for each (insn in body.code) {            
            var bandlabel = ticket++;
            var bandname = "b"+bandlabel;
            start = end;
            end = end + body.code.length;
            var color = ticket % 2 ? "grey" : "black";
            band_str += "\nband";
            band_str += " " + chrname;
            band_str += " " + bandname;
            band_str += " " + bandlabel;
            band_str += " " + start;
            band_str += " " + end;
            band_str += " " + color;
        }
        */

        var chr_str = "";
        var chrlabel = chr_count++;
        var chrname = kname+"_"+chrlabel;
        var start = 0;
        var end = body.code.length; //end = end + body.code.length;
        var color = "spectral-5-div-"+(chr_count%5+1);
        chr_str += "\nchr -";
        chr_str += " " + chrname;
        chr_str += " " + chrname;
        chr_str += " " + start;
        chr_str += " " + end;
        chr_str += " " + color;

        out_str += "\n" + chr_str + band_str;
    }
    return out_str;
}

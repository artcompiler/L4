/* -*- Mode: javascript; indent-tabs-mode: nil; tab-width: 4 -*- */
/* vi: set ts=4 sw=4 expandtab: (add to ~/.vimrc: set modeline modelines=5) */
/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is [Open Source Virtual Machine.].
 *
 * The Initial Developer of the Original Code is
 * Adobe System Incorporated.
 * Portions created by the Initial Developer are Copyright (C) 2004-2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *   Adobe AS3 Team
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */


public function eval(...args)
    ESC::evaluateInScopeArray(args, [], "");


// load asm
{
    use namespace "avmplus";
    use namespace "flash.utils";

    var fname = System.argv[0];
    if (fname==undefined) throw "no file name given";
    var fname = System.argv[0];
    var str = "var src = " + File.read (fname);
}

// parse json to object

{
    use namespace "avmplus";
    use namespace Parse;
    use namespace Gen;
    //print ("parsing");
    var top = [];
    var parser = new Parser(str,top);
    var nd = parser.program();
    var bytes = cg(nd).getBytes();
    Util::loadBytes(bytes);
}

// decode it

function getOffsetOfDefInBody(body, name) {
    for (var i=0; i<body.blocks[0].defs.length; i++) {
        //print("getOffsetOfDefInBody() name="+name+"="+ body.blocks[0].defs[i].name);
        if (body.blocks[0].defs[i].name == name) {
            return i;
        }
    }
    return 0;
}


function stripPunc(str) {
    return str.replace(/[_]/g, "-").replace(/ /g, "").replace(/[#.()]/g, "");
}

function genName({m, c, n, s, e, b, r, d, u}) {
    let name = ""
    // module
    if (m) {
        name += "M" + m
    }
    // closure
    if (c) {
        name += "C" + c
    }
    // table
    if (n) {
        name += "N" + n
    }
    // slot
    if (s) {
        name += "S" + s
    }
    // expression
    if (e) {
        name += "E" + e
    }
    // block
    if (b) {
        name += "B" + b
    }
    // reference
    if (r) {
        name += "R" + r
    }
    // def
    if (d) {
        name += "D" + d
    }
    // use
    if (u) {
        name += "U" + u
    }

    return name
}

var moduleNum = 0
function genModuleName() {
    moduleNum++
    return genName({m: moduleNum})
}

var closureNum = 0
function genClosureName() {
    closureNum++
    return genName({c: closureNum})
}

var nodeNum = 0
function genNodeName() {
    nodeNum++
    return genName({n: nodeNum})
}

var slotNum = 0
function genSlotName() {
    slotNum++
    return genName({s: slotNum})
}

var exprNum = 0
function genExprName() {
    exprNum++
    return genName({e: exprNum})
}

var blockNum = 0
function genBlockName() {
    blockNum++
    return genName({b: blockNum})
}

var refNum = 0
function genRefName() {
    refNum++
    return genName({r: refNum})
}

var defNum = 0
function genDefName() {
    defNum++
    return genName({d: defNum})
}

var useNum = 0
function genUseName() {
    useNum++
    return genName({u: useNum})
}

var nameStack = [ ]
function pushName(str) {
    if (!(str is String)) {
        throw str
    }
    print("pushName() " + nameStack.join("") + " " + str)
    nameStack.push(str)
    return str //nameStack.join("")
}

function popName() {
    let str = String(nameStack)
    nameStack.pop()
    return str
}


{
    genModuleName()

    var karyotypeStr = "";
    var configStr = "";
    var labelStr = "";
    var kname = fname.substring(fname.lastIndexOf("/")+1);
    var sharedLabelStr = ""
    var closureMap = { }
    var nodeMap = { }

    var linkStr = ""
    var nodesStr = ""

    for each (var closure in src.bods) {
        closure.id = genClosureName()
        closureMap[closure.id] = closure
        //print("bods closure.id="+closure.id+" closure.name="+closure.name)
        // init map from expr to closure
        for each (let expr in closure.blocks[0].exprs) {
            print("expr.id="+expr.id)
            let id = expr.id
            expr.name = genExprName()
            if (!nodeMap[id]) {
                nodeMap[id] = [ ]
            }
            nodeMap[id].push(closure.id)
        }
    }

    for each (let node in src.pool) {
        node.name = genNodeName()
    }


    let nodeIdeoSize    = 100000
    let closureIdeoSize = 100000
    let linkWidth = 10000

    for (let nid in src.pool) {
        let node = src.pool[nid]
        configStr = "";
        detailedConfigStr = "";
        linkStr = "";
        var rootName = fname+"."+node.name

        var nodeSize = getNodeSize(node)  // only count kids

        nodesStr += emitNodes({id: node.name, tokens: node.tokens});

        var offset = 1;
        var labelStr = sharedLabelStr;
        var others = []

        let count = 0
        for (let i=1; i < node.length; i++) {  // skip the first slot
            let slot = node[i]
            if (slot is int) {
                let slotId = node.name + "-" + count++
                let slotName = slot is String ? slot 
                    : slot is Number ? "N"+(slot+1)
                    : slotId
                let env = {
                    id: slotId,
                    name: slotName,
                    offset: nodeIdeoSize/2,    // for label
                    size: nodeIdeoSize,
                    label: slotName
                }
                karyotypeStr += emitChr(env)
                //nodesStr += emitNodes({id: slotId, tokens: slot.tokens});
                //linkStr = emitLink(env, linkStr);
                labelStr = emitLabel({id: slotId, size: nodeIdeoSize}, labelStr);
                offset++;   
            }

        }

        let size = nodeSize*nodeIdeoSize
        var env = {
            kname: kname,
            id: node.name,
            name: node.name,
            label: node[0],
            offset: 0,
            offset: size/2,    // for label
            scale: 20,
            size: size,
            nodes: src.pool,
            closures: closureMap
        }


        labelStr = emitLabel({id: node.name, size: size}, labelStr);
        [linkStr, labelStr] = emitNodeLink({id: nid, pool: src.pool, linkWidth: linkWidth, incoming: true}, linkStr, labelStr);
        karyotypeStr += emitChr(env)
        configStr += emitConfig(env, linkStr)
        detailedConfigStr += emitClosureOrNodeConfig(env, linkStr)

        Util::writeStringToFile(linkStr,rootName+".links");
        Util::writeStringToFile(labelStr,rootName+".labels");
        Util::writeStringToFile(configStr,rootName+".conf");
        print("rootName="+rootName)
        Util::writeStringToFile(detailedConfigStr,rootName+"-detail.conf");

    }

    for each (var closure in closureMap) {
        //print("closure="+typeof closure)
        configStr = ""
        detailedConfigStr = ""
        linkStr = ""

        var closureSize = closure.blocks[0].exprs.length;

        nodesStr += emitNodes({id: closure.id, tokens: closure.tokens});

        var offset = 1;
        var labelStr = sharedLabelStr;
        var others = []
        var rootName = fname+"."+closure.id


        let size = (closureSize?closureSize:closureSize+1)*closureIdeoSize
        var env = {
            kname: kname,
            id: closure.id,
            name: closure.name,
            label: closure.alias,
            offset: 0,
            offset: size/2,    // for label
            scale: 20,
            size: size,
            closures: closureMap,
            nodes: src.pool,
            path: [closure.id]
        }

        labelStr = emitLabel(env, labelStr);
        [linkStr, labelStr] = emitExprLinks({id: closure.id, exprs: closure.blocks[0].exprs, pool: src.pool, linkWidth: linkWidth}, linkStr, labelStr);
        karyotypeStr += emitChr(env)
        configStr += emitConfig(env, linkStr)
        detailedConfigStr += emitClosureOrNodeConfig(env, linkStr)


        for each (var expr in closure.blocks[0].exprs.reverse()) {

            let detailedExprConfigStr = exprLinkStr = ""
            let exprId = expr.name

            var env = {
                kname: kname,
                id: exprId,
                name: exprId,
                offset: closureIdeoSize/2,    // for label
                size: closureIdeoSize,
                label: exprId,
                path: [closure.id, expr.name],
                closures: closureMap,
                nodes: src.pool,
                scale: 20,
                path: [closure.id, exprId]
            }

            karyotypeStr += emitChr(env)
            nodesStr += emitNodes({id: exprId, tokens: expr.tokens});
            labelStr = emitLabel(env, labelStr);

            nodesStr += emitNodes({id: exprId, tokens: expr.tokens});
            labelStr = emitLabel(env, labelStr);

            [exprLinkStr, labelStr] = emitExprLink({id: closure.id, expr: expr, pool: src.pool, linkWidth: linkWidth}, exprLinkStr, labelStr);
            Util::writeStringToFile(exprLinkStr,rootName+"-"+exprId+".links");


            detailedExprConfigStr += emitExprConfig(env, linkStr)
            Util::writeStringToFile(detailedExprConfigStr,rootName+"-"+exprId+"-detail.conf");

            offset++;

        }

        //print("closure="+typeof closure)
        //print("closure.id="+closure.id);

        Util::writeStringToFile(linkStr,rootName+".links");
        Util::writeStringToFile(labelStr,rootName+".labels");
        Util::writeStringToFile(configStr,rootName+".conf");
        Util::writeStringToFile(detailedConfigStr,rootName+"-detail.conf");
    }

    Util::writeStringToFile(karyotypeStr,fname+".karyotype");
    Util::writeStringToFile(nodesStr,fname+".nodes");
}

function emitNodes({id, tokens}, str) {
    if (!str) {
        str = "";
    }

    if (id) {
        str += "\n" + id + " "
    }
 
    if (tokens) {
        for each (let t in tokens) {
            str += t + ","
        }
    }
    return str
}


function emitNodeLink({pool, id, linkWidth, incoming}, linkStr, labelStr) {

    let from = pool[id]

    if (!from) {
        return [linkStr, labelStr]
    }

    let outerWidth = getNodeSize(from)*nodeIdeoSize
    let outerSize = linkWidth
    let outerOffset = outerWidth / 2 - linkWidth / 2
    let outerId = getOuterId(id)

    let count = 0;
    // do outgoing links
    for (let i=0; i< from.length; i++) {
        if (from[i] is int) {

            let to = pool[from[i]]
            if (!to) {
                continue
            }

            let outerLinkId = getLinkId(id, i, 0)
            let linkId = getLinkId(id, i, from[i]+1)

            let fromId = getFromId(id, count++)
            let fromWidth = nodeIdeoSize
            let fromOffset = fromWidth / 2 - linkWidth / 2
            let fromSize = linkWidth

            let toId = getToId(from[i])
            let toWidth = getNodeSize(to)*nodeIdeoSize   //(to.length===0?1:to.length)*nodeIdeoSize
            let toOffset = toWidth / 2 - linkWidth / 2
            let toSize = linkWidth

            linkStr += outerLinkId + " " + outerId + " " + outerOffset + " " + (outerOffset+outerSize) + "\n" +
                       outerLinkId + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

            linkStr += linkId + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
                       linkId + " " + toId + " " + toOffset + " " + (toOffset+toSize)  + "\n";

            if (labelStr.indexOf(toId+" ") < 0) {
                labelStr += toId + " " + (toWidth / 2) + " " + (toWidth / 2) + " " + toId + "\n"
            }

            [linkStr, labelStr] = emitNodeLink({pool: pool, id: from[i], linkWidth: linkWidth, incoming: false}, linkStr, labelStr)
        }
    }

    // do incoming links
    let nodeLinks = nodeMap[id]
    if (incoming && nodeLinks) {
        for (let i=0; i< nodeLinks.length; i++) {

            let outerLinkId = getLinkId(id, i, 0)
            let linkId = getLinkId(id, i, i+1)
            
            let fromId = getFromId(id, 0)   // FIXME only links the first child of a node
            let fromWidth = nodeIdeoSize
            let fromOffset = fromWidth / 2 - linkWidth / 2
            let fromSize = linkWidth

            let toId = nodeLinks[i]
            let toClosure = closureMap[toId]
            let toWidth = getClosureSize(toClosure)*nodeIdeoSize   //(to.length===0?1:to.length)*nodeIdeoSize
            let toOffset = toWidth / 2 - linkWidth / 2
            let toSize = linkWidth

            linkStr += outerLinkId + " " + outerId + " " + outerOffset + " " + (outerOffset+outerSize) + " color=incomingcolor\n" +
                outerLinkId + " " + toId + " " + toOffset + " " + (toOffset+toSize) + " color=incomingcolor\n";
            
            linkStr += linkId + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + " color=incomingcolor\n" +
                linkId + " " + toId + " " + toOffset + " " + (toOffset+toSize) + " color=incomingcolor\n";

            if (labelStr.indexOf(toId+" ") < 0) {
                labelStr += toId + " " + (toWidth / 2) + " " + (toWidth / 2) + " " + toId + "\n"
            }

            [linkStr, labelStr] = emitNodeLink({pool: pool, id: from[i], linkWidth: linkWidth, incoming: false}, linkStr, labelStr)
        }
    }

    return [linkStr, labelStr]

    function getLinkId(x, y, z) {
        return "N" + (x+1) + "_" + y + "_" + z
    }

    function getFromId(n, i) {
        return "N" + (n+1) + "-" + i
    }

    function getToId(n) {
        return "N" + (n+1)
    }

    function getOuterId(n) {
        return "N" + (n+1)
    }

}

function getNodeSize(node) {
    let count = 0
    for each (let n in node) {
        if (n is int) {
            count++
        }
    }
    return count?count:1
}

function getClosureSize(closure) {
    return closure?closure.blocks[0].exprs.length:1
}

function emitExprLink({id:outerId, expr, pool, linkWidth}, linkStr, labelStr) {

    let to = pool[expr.id]

    let fromId = expr.name
    let fromWidth = closureIdeoSize
    let fromOffset = 0
    let fromSize = fromWidth
    let toId = "N" + (expr.id+1)
    let toWidth = getNodeSize(to)*nodeIdeoSize
    let toOffset = toWidth / 2 - linkWidth / 2
    let toSize = linkWidth

    linkStr += outerId + "_" + fromId + "_" + i + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
               outerId + "_" + fromId + "_" + i + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

    if (labelStr.indexOf(toId+" ") < 0) {
        labelStr += toId + " " + (toWidth / 2) + " " + (toWidth / 2) + " " + toId + "\n"
    }

    [linkStr, labelStr] = emitNodeLink({pool: pool, id: expr.id, linkWidth: linkWidth, incoming: false}, linkStr, labelStr)

    return [linkStr, labelStr]
}

function emitExprLinks({id:outerId, exprs, pool, linkWidth}, linkStr, labelStr) {

    let outerWidth = exprs.length * closureIdeoSize 
    let outerOffset = 0
    let outerSize = outerWidth

    for (let i=0; i< exprs.length; i++) {
        let to = pool[exprs[i].id]

        if (!to) {
            continue
        }

        let fromId = exprs[i].name
        let fromWidth = closureIdeoSize
        let fromOffset = 0
        let fromSize = fromWidth
        let toId = "N" + (exprs[i].id+1)
        let toWidth = getNodeSize(to)*nodeIdeoSize
        let toOffset = toWidth / 2 - linkWidth / 2
        let toSize = linkWidth

        linkStr += outerId + "_" + fromId + " " + outerId + " " + outerOffset + " " + (outerOffset+outerSize) + "\n" +
                   outerId + "_" + fromId + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";

        linkStr += outerId + "_" + fromId + "_" + i + " " + fromId + " " + fromOffset + " " + (fromOffset+fromSize) + "\n" +
                   outerId + "_" + fromId + "_" + i + " " + toId + " " + toOffset + " " + (toOffset+toSize) + "\n";


        if (labelStr.indexOf(toId+" ") < 0) {
            labelStr += toId + " " + (toWidth / 2) + " " + (toWidth / 2) + " " + toId + "\n"
        }

        [linkStr, labelStr] = emitNodeLink({pool: pool, id: exprs[i].id, linkWidth: linkWidth, incoming: false}, linkStr, labelStr)
    }

    return [linkStr, labelStr]
}

function emitChr({id, label, size}) {
    return "chr - " + id + " " + id + " 0 " + size + " gpos25\n";
}

function emitLabel({id, size}, out) {
    let offset = size/2
    var str = id + " " + offset + " " + offset + " " + id + "\n";
    if (out.indexOf(str) < 0) {
        out += str
    }
    return out
}

// Emit a Circos conf file for each body
function emitConfig({kname, name, id, scale, closures, tables, nodes}, linkStr) {
    var chrs = ""
    var radius = ""
    var color = ""

    for (let closureName in closures) {
        if (chrs.length > 0) {
            chrs += ";"
        }
        chrs += closures[closureName].id
    }

    for each (let node in nodes) {
        //print("emitConfig() node.name="+node.name)

        let nodeName = node.name
        if (chrs.length > 0) {
            chrs += ";"
        }
        chrs += nodeName
    }


    return "karyotype = ../" + kname + ".karyotype"
        + "\nchromosomes_units = " + closureIdeoSize
//        + "\nchromosomes_display_default = yes"
//        + "\nchromosomes_scale = "+ name + ":" + scale
        + "\nchromosomes = " + chrs
        + "\nchromosomes_color = /C/=closurecolor;/N/=tablecolor;"+id+"=highlightcolor"
        + "\n<<include ../" + kname + ".ideogram.conf>>"
        + "\n<<include ../" + kname + ".ticks.conf>>"
        + "\n<plots>"
        + "\n<plot>"
        + "\ntype = text"
        + "\ncolor = black"
        + "\nfile = ../" + kname + "." + id + ".labels"
        + "\nr0 = 1r+10p"
        + "\nr1 = 1r+200p"
        + "\nshow_links     = no"
//        + "\nlink_dims      = 4p,4p,8p,4p,4p"
//        + "\nlink_thickness = 1p"
//        + "\nlink_color     = grey"
        + "\nlabel_size   = 10p"
        + "\nlabel_color = grey"
        + "\nlabel_font   = condensed"
        + "\npadding  = 0p"
        + "\nrpadding = 0p"
        + "\n<rules>"
        + "\n <rule>"
        + "\n importance = 100"
        + "\n condition = eval( _CHR_ eq \"" + id + "\")"
        + "\n label_size = 10p"
        + "\n label_color = grey"
        + "\n link_color = white"
        + "\n </rule>"
        + "\n</rules>"
        + "\n</plot>"
        + "\n</plots>"
        + "\n<image>"
        + "\nfile  = ../" + kname + "." + id + ".svg"
        + "\n<<include ../image.conf>>"
        + "\n</image>"
        + "\n<<include ../housekeeping.conf>>"

        + "\n<links>"
        + "\nz = 0"
        + "\nradius = 0.95r"
        + "\nbezier_radius = 0r"
        + "\nbezier_radius_purity = 0.8"
        + "\n<link "+id+">"
        + "\nshow = yes"
        + "\ncolor = ribboncolor"
//        + "\nthickness = 1p"
        + "\nstroke_thickness = 1"
        + "\nstroke_color = ribbonborder"
        + "\nfile  = ../" + kname + "." + id + ".links"
        + "\nribbon = yes"
        + "\nflat = yes"
        + "\n<rules>"
        + "\n<rule>"
        + "\nimportance = 100"
        + "\ncondition  = 1"
        + "\nz = eval( -1 * scalar max(_SIZE2_,_SIZE1_) )"
        + "\n</rule>"
        + "\n</rules>"
        + "\n</link>"
        + "\n</links>"
}

// Emit a Circos conf file for each closure or node detail
function emitClosureOrNodeConfig({kname, id, name, scale, offset, size, closures, tables, nodes}, linkStr) {

    // show details of the current chr and hide details of the other chrs

    var chrs = ""

    var detailedRadius = ""
    var detailedColor = ""
    var detailedZoom = ""
    var detailedLabel = ""

    // for each closure, zoom into the expressions and nodes they depend on

    for (closureName in closures) {

        let closure = closures[closureName]

        print("id="+id+" name="+name+" closureName="+closureName)

        if (id != closureName) {
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closure.id
        }
        else if (closure.slots.length === 0 &&
                 closure.blocks[0].refs.length === 0) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closures[closureName].id

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = closures[closureName].id
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = 0u"
            detailedZoom += "\n end   = " + (size-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }

        if (id === closureName && closure.blocks[0].exprs.length > 0) {
            for each (var expr in closure.blocks[0].exprs) {
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                }
                if (detailedColor.length > 0) {
                    detailedColor += ";"
                }
                var detailedChr = expr.name

                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = 0u"
                detailedZoom += "\n end   = " + (nodeIdeoSize-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"

            }
        }

    }

    for each (let node in nodes) {
        let nodeName = node.name
        let nodeSize = getNodeSize(node)
        let nodeWidth = nodeSize * nodeIdeoSize

        if (nodeName != name) {
            // if not one of the linked nodes, then just add name to chrs
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName

            // show label for linked nodes
            if (!(linkStr.indexOf(nodeName+" ") < 0)) {
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                }
                if (detailedColor.length > 0) {
                    detailedColor += ";"
                }
                var detailedChr = nodeName
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=tablecolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = 0u"
                detailedZoom += "\n end   = " + (nodeWidth-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }
        }
        else if (nodeSize === 1) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = nodeName
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = 0u"
            detailedZoom += "\n end   = " + (nodeWidth-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }
        else {
            // otherwise, include detailed chrs
            let count = 0
            for (let i = 1; i < node.length; i++) {  // start with 1 to skip node kind
                if (node[i] is int) {
                    if (chrs.length > 0) {
                        chrs += ";"
                    }
                    if (detailedRadius.length > 0) {
                        detailedRadius += ";"
                        detailedColor += ";"
                    }
                    var detailedChr = nodeName+"-"+count++
                    chrs += detailedChr
                    detailedRadius += detailedChr + ":0.97r"
                    detailedColor += detailedChr + "=selectedcolor"
                    
                    detailedZoom += "\n <zoom>"
                    detailedZoom += "\n chr = " + detailedChr
                    detailedZoom += "\n start = 0u"
                    detailedZoom += "\n end   = " + (nodeIdeoSize-1) + "u"
                    detailedZoom += "\n scale = " + scale
                    detailedZoom += "\n </zoom>"
                    
                    detailedChr = detailedChr.replace("$", "\\\\$")
                    
                    detailedLabel += "\n <rule>"
                    detailedLabel += "\n importance = 100"
                    detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                    //                detailedLabel += "\n label_size = 10p"
                    detailedLabel += "\n label_color = grey"
                    detailedLabel += "\n link_color = white"
                    detailedLabel += "\n </rule>"
                }
            }
        }
    }

    let fileRoot = kname + "." + id

    print("fileRoot="+fileRoot)

    return "karyotype = ../" + kname + ".karyotype"
        + "\nchromosomes_units = " + closureIdeoSize
        + "\nchromosomes = " + chrs
//        + "\nchromosomes_display_default = yes"
//        + "\nchromosomes_scale = "+ id + ":" + scale
        + "\nchromosomes_color = /C/=closurecolor;/N/=tablecolor;"+detailedColor
        + "\nchromosomes_radius = "+ detailedRadius
        + "\n<<include ../" + kname + ".ideogram.conf>>"
        + "\n<<include ../" + kname + ".ticks.conf>>"
        + "\n<plots>"
        + "\n<plot>"
        + "\ntype = text"
        + "\ncolor = black"
        + "\nfile = ../" + fileRoot + ".labels"
        + "\nr0 = 1r+10p"
        + "\nr1 = 1r+200p"
        + "\nshow_links     = no"
//        + "\nlink_dims      = 4p,4p,8p,4p,4p"
//        + "\nlink_thickness = 1p"
//        + "\nlink_color     = grey"
        + "\nlabel_size   = 10p"
        + "\nlabel_color = grey"
        + "\nlabel_font   = condensed"
        + "\npadding  = 0p"
        + "\nrpadding = 0p"
        + "\n<rules>"
        + detailedLabel
        + "\n</rules>"
        + "\n</plot>"
        + "\n</plots>"
        + "\n<image>"
        + "\nfile  = ../" + fileRoot + "-detail.svg"
        + "\n<<include ../image.conf>>"
        + "\n</image>"
        + "\n<<include ../housekeeping.conf>>"
        + "\n<links>"
        + "\nz = 0"
        + "\nradius = 0.95r"
        + "\nbezier_radius = 0r"
        + "\nbezier_radius_purity = 0.8"
        + "\n<link "+id+">"
        + "\nshow = yes"
        + "\ncolor = ribboncolor"
//        + "\nthickness = 1p"
        + "\nstroke_thickness = 1"
        + "\nstroke_color = ribbonborder"
        + "\nfile  = ../" + fileRoot + ".links"
        + "\nribbon = yes"
        + "\nflat = yes"
        + "\n<rules>"
        + "\n<rule>"
        + "\nimportance = 100"
        + "\ncondition  = 1"
        + "\nz = eval( -1 * scalar max(_SIZE2_,_SIZE1_) )"
        + "\n</rule>"
        + "\n</rules>"
        + "\n</link>"
        + "\n</links>"
        + "\n<zooms>"
        + detailedZoom
        + "\n</zooms>"
}

// Emit a Circos conf file for each body detail
function emitExprConfig({kname, id, name, scale, offset, size, closures, tables, nodes, path}, linkStr) {

    // show details of the current chr and hide details of the other chrs

    var chrs = ""

    var detailedRadius = ""
    var detailedColor = ""
    var detailedZoom = ""
    var detailedLabel = ""

    // for each closure, zoom into the expressions and nodes they depend on

    for (closureName in closures) {


        let closure = closures[closureName]

        if (path.indexOf(closureName) < 0) {
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closure.id
        }
        else if (closure.slots.length === 0 &&
                 closure.blocks[0].refs.length === 0) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += closures[closureName].id

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = closures[closureName].id
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = 0u"
            detailedZoom += "\n end   = " + (size-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }

        if (path.indexOf(closureName) >= 0 && closure.blocks[0].exprs.length > 0) {
            for each (var expr in closure.blocks[0].exprs) {
                if (chrs.length > 0) {
                    chrs += ";"
                }
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                }
                if (detailedColor.length > 0) {
                    detailedColor += ";"
                }
                var detailedChr = expr.name

                chrs += detailedChr
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=selectedcolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = 0u"
                detailedZoom += "\n end   = " + (nodeIdeoSize-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"

            }
        }

    }

    print("path="+path+" chrs="+chrs)

    for each (let node in nodes) {
        let nodeName = node.name
        let nodeSize = getNodeSize(node)
        let nodeWidth = nodeSize * nodeIdeoSize

        if (nodeName != name) {
            // if not one of the linked nodes, then just add name to chrs
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName


            // show label for linked nodes
            if (!(linkStr.indexOf(nodeName+" ") < 0)) {
                if (detailedRadius.length > 0) {
                    detailedRadius += ";"
                }
                if (detailedColor.length > 0) {
                    detailedColor += ";"
                }
                var detailedChr = nodeName
                detailedRadius += detailedChr + ":0.97r"
                detailedColor += detailedChr + "=tablecolor"
                
                detailedZoom += "\n <zoom>"
                detailedZoom += "\n chr = " + detailedChr
                detailedZoom += "\n start = 0u"
                detailedZoom += "\n end   = " + (nodeWidth-1) + "u"
                detailedZoom += "\n scale = " + scale
                detailedZoom += "\n </zoom>"
                
                detailedLabel += "\n <rule>"
                detailedLabel += "\n importance = 100"
                detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//                detailedLabel += "\n label_size = 10p"
                detailedLabel += "\n label_color = grey"
                detailedLabel += "\n link_color = white"
                detailedLabel += "\n </rule>"
            }
        }
        else if (nodeSize === 1) {
            // if the focus chr, but no slots, then just add name
            if (chrs.length > 0) {
                chrs += ";"
            }
            chrs += nodeName

            if (detailedRadius.length > 0) {
                detailedRadius += ";"
                detailedColor += ";"
            }
            var detailedChr = nodeName
            detailedRadius += detailedChr + ":0.97r"
            detailedColor += detailedChr + "=selectedcolor"
            
            detailedZoom += "\n <zoom>"
            detailedZoom += "\n chr = " + detailedChr
            detailedZoom += "\n start = 0u"
            detailedZoom += "\n end   = " + (nodeWidth-1) + "u"
            detailedZoom += "\n scale = " + scale
            detailedZoom += "\n </zoom>"

            detailedLabel += "\n <rule>"
            detailedLabel += "\n importance = 100"
            detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
//            detailedLabel += "\n label_size = 10p"
            detailedLabel += "\n label_color = grey"
            detailedLabel += "\n link_color = white"
            detailedLabel += "\n </rule>"
        }
        else {
            // otherwise, include detailed chrs
            let count = 0
            for (let i = 1; i < node.length; i++) {  // start with 1 to skip node kind
                if (node[i] is int) {
                    if (chrs.length > 0) {
                        chrs += ";"
                    }
                    if (detailedRadius.length > 0) {
                        detailedRadius += ";"
                        detailedColor += ";"
                    }
                    var detailedChr = nodeName+"-"+count++
                    chrs += detailedChr
                    detailedRadius += detailedChr + ":0.97r"
                    detailedColor += detailedChr + "=selectedcolor"
                    
                    detailedZoom += "\n <zoom>"
                    detailedZoom += "\n chr = " + detailedChr
                    detailedZoom += "\n start = 0u"
                    detailedZoom += "\n end   = " + (nodeIdeoSize-1) + "u"
                    detailedZoom += "\n scale = " + scale
                    detailedZoom += "\n </zoom>"
                    
                    detailedChr = detailedChr.replace("$", "\\\\$")
                    
                    detailedLabel += "\n <rule>"
                    detailedLabel += "\n importance = 100"
                    detailedLabel += "\n condition = eval( _CHR_ eq \"" + detailedChr + "\")"
                    //                detailedLabel += "\n label_size = 10p"
                    detailedLabel += "\n label_color = grey"
                    detailedLabel += "\n link_color = white"
                    detailedLabel += "\n </rule>"
                }
            }
        }
    }

    let fileRoot = kname + "." + path[0]
    let fileName = kname + "." + path[1]
    //for (let i = 1; i < path.length; i++) {
    //    fileName += "." + path[i]
    //}

    return "karyotype = ../" + kname + ".karyotype"
        + "\nchromosomes_units = " + closureIdeoSize
        + "\nchromosomes = " + chrs
//        + "\nchromosomes_display_default = yes"
//        + "\nchromosomes_scale = "+ id + ":" + scale
        + "\nchromosomes_color = /C/=closurecolor;/N/=tablecolor;"+detailedColor
        + "\nchromosomes_radius = "+ detailedRadius
        + "\n<<include ../" + kname + ".ideogram.conf>>"
        + "\n<<include ../" + kname + ".ticks.conf>>"
        + "\n<plots>"
        + "\n<plot>"
        + "\ntype = text"
        + "\ncolor = black"
        + "\nfile = ../" + fileRoot + ".labels"
        + "\nr0 = 1r+10p"
        + "\nr1 = 1r+200p"
        + "\nshow_links     = no"
//        + "\nlink_dims      = 4p,4p,8p,4p,4p"
//        + "\nlink_thickness = 1p"
//        + "\nlink_color     = grey"
        + "\nlabel_size   = 10p"
        + "\nlabel_color = grey"
        + "\nlabel_font   = condensed"
        + "\npadding  = 0p"
        + "\nrpadding = 0p"
        + "\n<rules>"
        + detailedLabel
        + "\n</rules>"
        + "\n</plot>"
        + "\n</plots>"
        + "\n<image>"
        + "\nfile  = ../" + fileName + "-detail.svg"
        + "\n<<include ../image.conf>>"
        + "\n</image>"
        + "\n<<include ../housekeeping.conf>>"
        + "\n<links>"
        + "\nz = 0"
        + "\nradius = 0.95r"
        + "\nbezier_radius = 0r"
        + "\nbezier_radius_purity = 0.8"
        + "\n<link "+id+">"
        + "\nshow = yes"
        + "\ncolor = ribboncolor"
//        + "\nthickness = 1p"
        + "\nstroke_thickness = 1"
        + "\nstroke_color = ribbonborder"
        + "\nfile  = ../" + fileRoot + "-" + path[1] + ".links"
        + "\nribbon = yes"
        + "\nflat = yes"
        + "\n<rules>"
        + "\n<rule>"
        + "\nimportance = 100"
        + "\ncondition  = 1"
        + "\nz = eval( -1 * scalar max(_SIZE2_,_SIZE1_) )"
        + "\n</rule>"
        + "\n</rules>"
        + "\n</link>"
        + "\n</links>"
        + "\n<zooms>"
        + detailedZoom
        + "\n</zooms>"
}

public function compileHook (s:String)
{
    var t0 = new Date;
    var maker = new SwfMaker ();
    var bytes = ESC::compileStringToBytes (s);
    var bytes = maker.makeSwf ([bytes], null);
    print (bytes.length + " bytes in " + (new Date() - t0) + " ms");
    return bytes;
}



// chr - CHRNAME CHRLABEL START END COLOR
//      "       method#  0 size "

function karyoFromAbc(fname, abc) {
    var chr_count = 1;
    var ticket = 1;
    var out_str = "";
    var code_size = 0;
    var kname = fname.substring(fname.lastIndexOf("/")+1, fname.lastIndexOf("."));
    var start;
    var end = 0;

    for each (body in abc.bodies) {
        var band_str = "";
        /*
        for each (insn in body.code) {            
            var bandlabel = ticket++;
            var bandname = "b"+bandlabel;
            start = end;
            end = end + body.code.length;
            var color = ticket % 2 ? "grey" : "black";
            band_str += "\nband";
            band_str += " " + chrname;
            band_str += " " + bandname;
            band_str += " " + bandlabel;
            band_str += " " + start;
            band_str += " " + end;
            band_str += " " + color;
        }
        */

        var chr_str = "";
        var chrlabel = chr_count++;
        var chrname = kname+"_"+chrlabel;
        var start = 0;
        var end = body.code.length; //end = end + body.code.length;
        var color = "spectral-5-div-"+(chr_count%5+1);
        chr_str += "\nchr -";
        chr_str += " " + chrname;
        chr_str += " " + chrname;
        chr_str += " " + start;
        chr_str += " " + end;
        chr_str += " " + color;

        out_str += "\n" + chr_str + band_str;
    }
    return out_str;
}
